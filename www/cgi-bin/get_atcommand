#!/bin/bash
set -eu

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=/dev/null
. "$SCRIPT_DIR/session_utils.sh"

if ! session_load; then
    send_json_response 401 '{"success":false,"message":"Authentication required"}'
    exit 0
fi

# URL decode helper
urldecode() {
    local data="${1//+/ }"
    printf '%b' "${data//%/\\x}"
}

# Parse query string
raw_query="${QUERY_STRING:-}"
atcmd_param=""

if [ -n "$raw_query" ]; then
    IFS='&' read -r -a pairs <<< "$raw_query"
    for pair in "${pairs[@]}"; do
        key="${pair%%=*}"
        value="${pair#*=}"
        if [ "$key" = "atcmd" ]; then
            atcmd_param="$value"
        fi
    done
fi

# Validate atcmd parameter
if [ -z "$atcmd_param" ]; then
    send_json_response 400 '{"success":false,"message":"Missing atcmd parameter"}'
    exit 0
fi

# Decode the AT command(s)
decoded_atcmd="$(urldecode "$atcmd_param")"
if [ -z "$decoded_atcmd" ]; then
    send_json_response 400 '{"success":false,"message":"Unable to decode the atcmd parameter"}'
    exit 0
fi

# Resolve AT CLI binary (force /usr/bin/atcli_smd11)
ATCLI_BIN="/usr/bin/atcli_smd11"
if [ ! -x "$ATCLI_BIN" ]; then
    send_json_response 500 '{"success":false,"message":"atcli_smd11 not found or not executable"}'
    exit 0
fi

# Serialize AT command access to prevent collisions
LOCK_FILE="/tmp/atcommand.lock"
exec 200>"$LOCK_FILE"
lock_acquired=false
for _ in $(seq 1 20); do
    if flock -n 200; then
        lock_acquired=true
        break
    fi
    sleep 1
done
if [ "$lock_acquired" != "true" ]; then
    send_json_response 503 '{"success":false,"message":"AT port busy","busy":true}'
    exit 0
fi

# Execute a single AT command with retry logic
run_atcli() {
    local cmd="$1"
    local max_attempts=1
    local attempt=1
    local exit_code=1
    local output=""
    local busy_detected=false
    local timeout_detected=false

    while [ $attempt -le $max_attempts ]; do
        output="$(timeout -t 6 "$ATCLI_BIN" "$cmd" 2>&1)"
        exit_code=$?

        if [ $exit_code -eq 124 ] || [ $exit_code -eq 143 ]; then
            timeout_detected=true
        fi

        if [ $exit_code -eq 0 ]; then
            if echo "$output" | grep -qiE 'device busy|resource busy|port busy|in use'; then
                busy_detected=true
            fi
            if echo "$output" | grep -qE 'OK|ERROR'; then
                break
            fi
        else
            if echo "$output" | grep -qiE 'busy|in use|locked'; then
                busy_detected=true
            fi
        fi

        if [ $attempt -lt $max_attempts ]; then
            sleep 1
        fi
        attempt=$((attempt + 1))
    done

    printf '%s\n' "$attempt|$exit_code|$busy_detected|$timeout_detected|$output"
}

combined_output=""
busy_any=false
has_error=false
any_output=false
any_success=false
error_count=0
max_attempts_used=0

IFS=';' read -r -a commands <<< "$decoded_atcmd"
for cmd in "${commands[@]}"; do
    cmd="$(echo "$cmd" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    [ -z "$cmd" ] && continue

    result="$(run_atcli "$cmd")"
    attempt="${result%%|*}"
    rest="${result#*|}"
    exit_code="${rest%%|*}"
    rest="${rest#*|}"
    busy_detected="${rest%%|*}"
    rest="${rest#*|}"
    timeout_detected="${rest%%|*}"
    output="${rest#*|}"

    if [ "$attempt" -gt "$max_attempts_used" ]; then
        max_attempts_used="$attempt"
    fi

    if [ "$busy_detected" = "true" ]; then
        busy_any=true
    fi

    if [ -n "$output" ]; then
        any_output=true
    fi

    if [ "$exit_code" -eq 0 ]; then
        any_success=true
    else
        has_error=true
        error_count=$((error_count + 1))
        if [ -z "$output" ]; then
            if [ "$timeout_detected" = "true" ]; then
                output="ERROR: TIMEOUT"
            elif [ "$busy_detected" = "true" ]; then
                output="ERROR: BUSY"
            else
                output="ERROR"
            fi
        fi
    fi

    # Note: do not propagate ERROR as hard failure; keep data flowing

    if [ -z "$combined_output" ]; then
        combined_output="$output"
    else
        combined_output="${combined_output}"$'\n'"$output"
    fi
done

if [ -z "$combined_output" ] || [ "$any_output" != "true" ]; then
    send_json_response 500 '{"success":false,"message":"Empty response from modem","command":"'"$(json_escape "$decoded_atcmd")"'"}'
    exit 0
fi

payload=$(cat <<EOF
{
  "success":true,
  "command":"$(json_escape "$decoded_atcmd")",
  "output":"$(json_escape "$combined_output")",
  "exit_code":0,
  "busy":false,
  "attempts":$max_attempts_used,
  "has_error":false,
  "partial_errors":$error_count
}
EOF
)

send_json_response 200 "$payload"
