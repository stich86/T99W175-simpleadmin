#!/bin/bash
set -euo pipefail

CONFIG_FILE="/etc/data/mobileap_cfg.xml"
TMP_FILE="/tmp/mobileap_cfg_tmp.xml"

send_response() {
    local status=$1
    local message=$2
    cat <<JSON
Content-type: application/json

{ "ok": ${status}, "message": "${message}" }
JSON
}

urldecode() {
    local data="${1//+/ }"
    printf '%b' "${data//%/\\x}"
}

parse_input() {
    local raw="$1"
    local key value
    local -a pairs=()

    IFS='&' read -ra pairs <<< "$raw"
    for kv in "${pairs[@]}"; do
        key=${kv%%=*}
        value=${kv#*=}
        [ -z "$key" ] && continue
        value=$(urldecode "$value")
        case "$key" in
            ip) IP_VALUE="$value" ;;
            subnet) SUBNET_VALUE="$value" ;;
            dhcpEnabled) DHCP_ENABLED_VALUE="$value" ;;
            dhcpStart) DHCP_START_VALUE="$value" ;;
            dhcpEnd) DHCP_END_VALUE="$value" ;;
            dhcpLease) DHCP_LEASE_VALUE="$value" ;;
        esac
    done
}

is_valid_ipv4() {
    local ip=$1
    local IFS='.'
    local -a octets
    read -r -a octets <<< "$ip"

    if [ "${#octets[@]}" -ne 4 ]; then
        return 1
    fi

    for octet in "${octets[@]}"; do
        if ! [[ $octet =~ ^[0-9]+$ ]]; then
            return 1
        fi
        if [ "$octet" -lt 0 ] || [ "$octet" -gt 255 ]; then
            return 1
        fi
    done

    return 0
}

is_valid_netmask() {
    local mask=$1
    case "$mask" in
        255.255.255.255|255.255.255.254|255.255.255.252|255.255.255.248|
        255.255.255.240|255.255.255.224|255.255.255.192|255.255.255.128|
        255.255.255.0|255.255.254.0|255.255.252.0|255.255.248.0|
        255.255.240.0|255.255.224.0|255.255.192.0|255.255.128.0|
        255.255.0.0|255.254.0.0|255.252.0.0|255.248.0.0|
        255.240.0.0|255.224.0.0|255.192.0.0|255.128.0.0|
        255.0.0.0|254.0.0.0|252.0.0.0|248.0.0.0|
        240.0.0.0|224.0.0.0|192.0.0.0|128.0.0.0|0.0.0.0)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

ip_to_int() {
    local IFS='.'
    local -a octets
    read -r -a octets <<< "$1"
    printf '%u' $(( (octets[0] << 24) + (octets[1] << 16) + (octets[2] << 8) + octets[3] ))
}

apply_value() {
    local key=$1
    local value=$2

    if grep -q "<$key>" "$CONFIG_FILE"; then
        sed "s|<$key>.*</$key>|<$key>$value</$key>|" "$CONFIG_FILE" > "$TMP_FILE"
        mv "$TMP_FILE" "$CONFIG_FILE"
    fi
}

main() {
    if [ ! -f "$CONFIG_FILE" ]; then
        send_response false "Configuration file not found"
        exit 0
    fi

    local data=""

    if [ "${REQUEST_METHOD:-GET}" = "POST" ]; then
        if [ -n "${CONTENT_LENGTH:-}" ]; then
            read -r -n "$CONTENT_LENGTH" data
        else
            read -r data
        fi
    else
        data=$QUERY_STRING
    fi

    parse_input "$data"

    IP_VALUE=${IP_VALUE:-}
    SUBNET_VALUE=${SUBNET_VALUE:-}
    DHCP_ENABLED_VALUE=${DHCP_ENABLED_VALUE:-}
    DHCP_START_VALUE=${DHCP_START_VALUE:-}
    DHCP_END_VALUE=${DHCP_END_VALUE:-}
    DHCP_LEASE_VALUE=${DHCP_LEASE_VALUE:-}

    if [ -z "$IP_VALUE" ] || ! is_valid_ipv4 "$IP_VALUE"; then
        send_response false "Indirizzo IP non valido"
        exit 0
    fi

    if [ -z "$SUBNET_VALUE" ] || ! is_valid_netmask "$SUBNET_VALUE"; then
        send_response false "Subnet mask non valida"
        exit 0
    fi

    if [ -z "$DHCP_ENABLED_VALUE" ] || ! [[ "$DHCP_ENABLED_VALUE" =~ ^[01]$ ]]; then
        send_response false "Valore DHCP non valido"
        exit 0
    fi

    if [ "$DHCP_ENABLED_VALUE" = "1" ]; then
        if [ -z "$DHCP_START_VALUE" ] || ! is_valid_ipv4 "$DHCP_START_VALUE"; then
            send_response false "Indirizzo iniziale DHCP non valido"
            exit 0
        fi
        if [ -z "$DHCP_END_VALUE" ] || ! is_valid_ipv4 "$DHCP_END_VALUE"; then
            send_response false "Indirizzo finale DHCP non valido"
            exit 0
        fi

        local ip_int start_int end_int
        ip_int=$(ip_to_int "$IP_VALUE")
        start_int=$(ip_to_int "$DHCP_START_VALUE")
        end_int=$(ip_to_int "$DHCP_END_VALUE")

        if [ "$start_int" -gt "$end_int" ]; then
            send_response false "L'indirizzo iniziale DHCP deve essere precedente o uguale all'indirizzo finale"
            exit 0
        fi
    fi

    if [ -n "$DHCP_LEASE_VALUE" ]; then
        if ! [[ "$DHCP_LEASE_VALUE" =~ ^[0-9]+$ ]]; then
            send_response false "Lease time non valido"
            exit 0
        fi
    else
        DHCP_LEASE_VALUE="86400"
    fi

    apply_value "APIPAddr" "$IP_VALUE"
    apply_value "SubNetMask" "$SUBNET_VALUE"
    apply_value "EnableDHCPServer" "$DHCP_ENABLED_VALUE"

    if [ "$DHCP_ENABLED_VALUE" = "1" ]; then
        apply_value "StartIP" "$DHCP_START_VALUE"
        apply_value "EndIP" "$DHCP_END_VALUE"
    fi

    apply_value "LeaseTime" "$DHCP_LEASE_VALUE"

    sync

    send_response true "Configurazione aggiornata"
}

main "$@"
