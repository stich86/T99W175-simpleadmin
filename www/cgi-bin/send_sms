#!/bin/bash
set -eu

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=/dev/null
. "$SCRIPT_DIR/session_utils.sh"

if ! session_load; then
    printf 'Status: 401 Unauthorized\r\n'
    printf 'Content-type: text/plain\r\n\r\n'
    printf 'Authentication required\n'
    exit 0
fi

if ! session_require_role "admin"; then
    printf 'Status: 403 Forbidden\r\n'
    printf 'Content-type: text/plain\r\n\r\n'
    printf 'Admin privileges required\n'
    exit 0
fi

# Remove potential dangerous characters
QUERY_STRING=$(echo "${QUERY_STRING}" | sed 's/;//g')

urldecode() {
    local data
    data="${*//+/ }"
    printf '%b' "${data//%/\\x}"
}

if [ "${QUERY_STRING}" ]; then
    export IFS="&"
    for cmd in ${QUERY_STRING}; do
        if [[ "$cmd" == *=* ]]; then
            key=$(echo "$cmd" | awk -F '=' '{print $1}')
            value=$(echo "$cmd" | awk -F '=' '{print $2}')
            eval "$key"="$(urldecode "$value")"
        fi
    done
fi

phone_number="$number"
message_encoded="$msg"
command_param="$Command"

# Convert UCS2 hex to actual text for phone number
hex_to_text() {
    local hex=$1
    echo -n "$hex" | sed 's/../\\x&/g' | xargs -0 printf
}

# Send SMS using direct serial communication with proper text mode
send_sms() {
    local phone=$1
    local msg=$2
    local cmd_param=$3
    local device="/dev/smd8"
    
    # Configure serial port
    stty -F "$device" 115200 cs8 -cstopb -parenb -echo raw 2>/dev/null
    
    # Start a background process to read responses
    {
        # Clear any pending data
        timeout 0.5 cat "$device" > /dev/null 2>&1
        
        # Initialize modem for text mode SMS with UCS2
        echo -e "AT+CMGF=1\r" > "$device"
        sleep 0.5
        timeout 1 cat "$device" 2>&1
        
        echo -e "AT+CSCS=\"UCS2\"\r" > "$device"
        sleep 0.5
        timeout 1 cat "$device" 2>&1
        
        # Set SMS parameters for UCS2
        echo -e "AT+CSMP=17,167,0,8\r" > "$device"
        sleep 0.5
        timeout 1 cat "$device" 2>&1
        
        # Send CMGS command with phone number in UCS2
        echo -e "AT+CMGS=\"${phone}\"\r" > "$device"
        sleep 1
        
        # Wait for prompt (>) and capture it
        local prompt
        prompt=$(timeout 2 cat "$device" 2>&1)
        echo "$prompt"
        
        # Send message in UCS2 hex format followed by Ctrl+Z
        echo -en "${msg}\x1A" > "$device"
        sleep 3
        
        # Capture final response
        timeout 5 cat "$device" 2>&1
    }
}

# Alternative method using expect-like script
send_sms_interactive() {
    local phone=$1
    local msg=$2
    local cmd_param=$3
    
    # Create expect-like script
    cat << EOF | sh
#!/bin/sh
exec 3<>/dev/smd8
stty -F /dev/smd8 115200 cs8 -cstopb -parenb -echo raw 2>/dev/null

# Clear buffer
timeout 0.5 cat <&3 >/dev/null 2>&1

# Initialize
echo -e "AT+CMGF=1\r" >&3
sleep 0.5
timeout 1 cat <&3 2>&1

echo -e "AT+CSCS=\"UCS2\"\r" >&3
sleep 0.5
timeout 1 cat <&3 2>&1

echo -e "AT+CSMP=17,167,0,8\r" >&3
sleep 0.5
timeout 1 cat <&3 2>&1

# Send CMGS
echo -e "AT+CMGS=\"${phone}\"\r" >&3
sleep 1

# Read until we get >
while IFS= read -r -t 2 -u 3 line; do
    echo "\$line"
    if echo "\$line" | grep -q ">"; then
        break
    fi
done

# Send message + Ctrl+Z
echo -en "${msg}\x1A" >&3
sleep 3

# Read response
timeout 5 cat <&3 2>&1

exec 3>&-
exec 3<&-
EOF
}

# Method using named pipes for better control
send_sms_pipe() {
    local phone=$1
    local msg=$2
    local device="/dev/smd8"
    
    # Create named pipes for input/output
    local inpipe=$(mktemp -u)
    local outpipe=$(mktemp -u)
    mkfifo "$inpipe" "$outpipe"
    
    # Start reader in background
    cat "$device" > "$outpipe" &
    local cat_pid=$!
    
    # Start writer
    {
        # Initialize
        echo "AT+CMGF=1"
        sleep 0.5
        echo "AT+CSCS=\"UCS2\""
        sleep 0.5
        echo "AT+CSMP=17,167,0,8"
        sleep 0.5
        
        # Send CMGS
        echo "AT+CMGS=\"${phone}\""
        sleep 1.5
        
        # Send message with Ctrl+Z
        echo -en "${msg}\x1A"
        sleep 3
    } > "$device" &
    local writer_pid=$!
    
    # Read output for 5 seconds
    timeout 5 cat "$outpipe" 2>&1
    
    # Cleanup
    kill $cat_pid 2>/dev/null
    kill $writer_pid 2>/dev/null
    wait $cat_pid 2>/dev/null
    wait $writer_pid 2>/dev/null
    rm -f "$inpipe" "$outpipe"
}

# Send response header
printf 'Content-type: text/plain\r\n\r\n'

# Validate input
if [ -z "$phone_number" ] || [ -z "$message_encoded" ]; then
    echo "Error: Missing phone number or message"
    exit 1
fi

# Try sending SMS
result=$(send_sms "$phone_number" "$message_encoded" "$command_param" 2>&1)

# If first method doesn't work well, try interactive method
if [ -z "$result" ] || ! echo "$result" | grep -qE "(OK|ERROR|\+CMGS)"; then
    result=$(send_sms_interactive "$phone_number" "$message_encoded" "$command_param" 2>&1)
fi

# If still no good result, try pipe method
if [ -z "$result" ] || ! echo "$result" | grep -qE "(OK|ERROR|\+CMGS)"; then
    result=$(send_sms_pipe "$phone_number" "$message_encoded" 2>&1)
fi

# Parse and return result
if echo "$result" | grep -q "+CMS ERROR"; then
    error_code=$(echo "$result" | grep "+CMS ERROR" | sed 's/.*+CMS ERROR: \([0-9]*\).*/\1/')
    echo "+CMS ERROR: $error_code"
    echo "$result"
elif echo "$result" | grep -qE "(OK|\+CMGS:)"; then
    echo "OK"
    echo "$result"
else
    echo "Error: No valid response from modem"
    echo "$result"
fi