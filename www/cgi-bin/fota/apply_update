#!/bin/bash

# SimpleAdmin Update System - Apply Update
# Creates backup, extracts update, and applies it to /www

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source session utilities
if [ -f "$SCRIPT_DIR/../session_utils.sh" ]; then
    . "$SCRIPT_DIR/../session_utils.sh"
else
    send_json_response 500 '{"ok": false, "message": "session_utils.sh not found"}'
    exit 1
fi

# Validate session and require admin
if ! session_load; then
    send_json_response 401 '{"ok": false, "message": "Invalid or expired session"}'
    exit 1
fi

if ! session_require_role "admin"; then
    send_json_response 403 '{"ok": false, "message": "Admin privileges required"}'
    exit 1
fi

# Configuration
STATE_DIR="/data/simpleadmin"
STATE_FILE="${STATE_DIR}/update-state.json"
BACKUP_DIR="${STATE_DIR}/backups"
STAGING_DIR="${STATE_DIR}/staging"
CONFIG_BACKUP_DIR="${STATE_DIR}/config_backup"
WWW_DIR="/WEBSERVER/www"

# Files to preserve during update
PRESERVE_FILES=(
    "config/simpleadmin.conf"
    "cgi-bin/credentials.txt"
)

# Create directories
mkdir -p "${BACKUP_DIR}"
mkdir -p "${STAGING_DIR}"
mkdir -p "${CONFIG_BACKUP_DIR}"

# Helper functions
send_fota_response() {
    local ok=$1
    local message=$2
    local data=$3

    local payload
    payload="{\"ok\": $ok, \"message\": \"$message\", \"data\": $data}"

    send_json_response 200 "$payload"
}

log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1" >&2
}

log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] INFO: $1" >&2
}

# Backup configuration files
backup_config_files() {
    log_info "Backing up configuration files..."

    for file in "${PRESERVE_FILES[@]}"; do
        local filepath="${WWW_DIR}/${file}"
        local backuppath="${CONFIG_BACKUP_DIR}/$(basename $file)"

        if [ -f "$filepath" ]; then
            log_info "  Backing up: $file"
            cp "$filepath" "$backuppath"
        else
            log_info "  File not found (will be created): $file"
        fi
    done

    log_info "Configuration backup completed"
}

# Restore configuration files
restore_config_files() {
    log_info "Restoring configuration files..."

    for file in "${PRESERVE_FILES[@]}"; do
        local filepath="${WWW_DIR}/${file}"
        local backuppath="${CONFIG_BACKUP_DIR}/$(basename $file)"

        if [ -f "$backuppath" ]; then
            log_info "  Restoring: $file"
            cp "$backuppath" "$filepath"

            # Ensure proper permissions
            if [ "$file" = "config/credentials.txt" ]; then
                chmod 600 "$filepath"
            else
                chmod 644 "$filepath"
            fi
        else
            log_info "  No backup found for: $file"
        fi
    done

    log_info "Configuration restoration completed"
}


# Extract field from JSON using grep/sed
extract_json_field() {
    local json=$1
    local field=$2
    echo "$json" | grep "\"$field\":" | sed 's/.*"'$field'" *: *"\([^"]*\)".*/\1/' | head -n 1
}

# Extract boolean field from JSON
extract_json_bool() {
    local json=$1
    local field=$2
    echo "$json" | grep "\"$field\":" | sed 's/.*"'$field'" *: *\([^,}]*\).*/\1/' | head -n 1
}

# Update state file (without jq)
update_state() {
    local status=$1
    local backup_path=$2
    local error_msg=$3

    local backed_up="false"
    if [ -n "$backup_path" ]; then
        backed_up="true"
    fi

    # Use sed to update fields
    if [ -n "$status" ]; then
        sed -i "s/\"status\": \"[^\"]*\"/\"status\": \"$status\"/" "$STATE_FILE"
    fi

    if [ -n "$backup_path" ]; then
        sed -i "s|\"backup_path\": \"[^\"]*\"|\"backup_path\": \"$backup_path\"|" "$STATE_FILE"
    fi

    if [ -n "$error_msg" ]; then
        sed -i "s/\"error_message\": \"[^\"]*\"/\"error_message\": \"$error_msg\"/" "$STATE_FILE"
    fi

    sed -i "s/\"backup_created\": [^,}]*/\"backup_created\": $backed_up/" "$STATE_FILE"
}

# Create backup of current www
create_backup() {
    local backup_file="${BACKUP_DIR}/www_previous.tar.gz"

    log_info "Creating backup: $backup_file"

    # Remove old backup if exists
    if [ -f "$backup_file" ]; then
        log_info "Removing old backup..."
        rm -f "$backup_file"
    fi

    # Create backup
    if ! tar czf "$backup_file" -C / www 2>/dev/null; then
        log_error "Failed to create backup"
        return 1
    fi

    # Verify backup
    if [ ! -f "$backup_file" ] || [ $(stat -c%s "$backup_file" 2>/dev/null || stat -f%z "$backup_file" 2>/dev/null) -lt 1000 ]; then
        log_error "Backup file is invalid or too small"
        return 1
    fi

    log_info "Backup created successfully"
    echo "$backup_file"
    return 0
}

# Extract downloaded archive
extract_update() {
    local archive=$1
    local extract_dir=$2

    log_info "Extracting update to: $extract_dir"

    # Clean staging directory
    rm -rf "${extract_dir:?}/"*
    mkdir -p "$extract_dir"

    # Extract archive
    if ! tar xzf "$archive" -C "$extract_dir" 2>/dev/null; then
        log_error "Failed to extract archive"
        return 1
    fi

    # Check if www directory exists in extraction
    if [ ! -d "$extract_dir/www" ]; then
        log_error "Extracted archive does not contain www directory"
        return 1
    fi

    log_info "Archive extracted successfully"
    return 0
}

# Apply update by replacing www directory
apply_update_files() {
    local staging_www=$1

    log_info "Applying update to $WWW_DIR"

    # Move old www directory to backup (atomic operation)
    log_info "Moving old www directory to backup..."
    if ! mv "$WWW_DIR" "${WWW_DIR}.old"; then
        log_error "Failed to move old www directory"
        return 1
    fi

    # Move new www directory into place (atomic operation)
    log_info "Moving new files into place..."
    if ! mv "$staging_www" "$WWW_DIR"; then
        log_error "Failed to move new files"
        # Try to restore old directory
        mv "${WWW_DIR}.old" "$WWW_DIR"
        systemctl restart qcmap_httpd 2>/dev/null
        return 1
    fi

    # Set permissions
    chmod -R 755 "$WWW_DIR"
    chmod +x "$WWW_DIR"/cgi-bin/* 2>/dev/null

    # Restore configuration files
    log_info "Restoring configuration files..."
    restore_config_files

    # Start web server
    log_info "Restarting web server..."
    systemctl restart qcmap_httpd

    # Wait a moment for server to start
    sleep 2

    # Cleanup old directory in background
    log_info "Cleaning up old www directory..."
    rm -rf "${WWW_DIR}.old" 2>/dev/null &

    log_info "Update applied successfully"
    return 0
}

# Main execution
main() {
    # Check if state file exists
    if [ ! -f "$STATE_FILE" ]; then
        log_error "State file not found"
        send_fota_response "false" "Update state not found" "{}"
        exit 1
    fi

    # Read state
    local state_data
    state_data=$(cat "$STATE_FILE" 2>/dev/null)

    if [ -z "$state_data" ]; then
        log_error "Failed to read state file"
        send_fota_response "false" "Failed to read state file" "{}"
        exit 1
    fi

    # Extract fields
    local update_downloaded
    update_downloaded=$(extract_json_bool "$state_data" "update_downloaded")

    local download_path
    download_path=$(extract_json_field "$state_data" "download_path")

    local latest_version
    latest_version=$(extract_json_field "$state_data" "latest_version")

    # Validate preconditions
    if [ "$update_downloaded" != "true" ]; then
        send_fota_response "false" "Update not downloaded yet" "{}"
        exit 1
    fi

    if [ -z "$download_path" ] || [ "$download_path" = "null" ]; then
        send_fota_response "false" "Download path not found" "{}"
        exit 1
    fi

    if [ ! -f "$download_path" ]; then
        log_error "Downloaded file not found: $download_path"
        update_state "error" "" "Downloaded file missing"
        send_fota_response "false" "Downloaded file not found" "{}"
        exit 1
    fi

    # Update status to updating
    update_state "updating" "" ""

    # Step 0: Backup configuration files
    log_info "Step 0: Backing up configuration files..."
    backup_config_files

    # Step 1: Create backup
    log_info "Step 1: Creating backup..."
    backup_file=""
    if ! backup_file=$(create_backup); then
        update_state "error" "" "Failed to create backup"
        send_fota_response "false" "Failed to create backup" "{}"
        exit 1
    fi

    # Step 2: Extract update
    log_info "Step 2: Extracting update..."
    if ! extract_update "$download_path" "$STAGING_DIR"; then
        update_state "error" "$backup_file" "Failed to extract update"
        send_fota_response "false" "Failed to extract update" "{}"
        exit 1
    fi

    # Step 3: Apply update
    log_info "Step 3: Applying update..."
    if ! apply_update_files "${STAGING_DIR}/www"; then
        update_state "error" "$backup_file" "Failed to apply update"
        send_fota_response "false" "Failed to apply update" "{}"
        exit 1
    fi

    # Step 4: Cleanup staging
    log_info "Step 4: Cleanup..."
    rm -rf "${STAGING_DIR:?}"/www

    # Update state to success
    update_state "success" "$backup_file" ""

    log_info "Update completed successfully!"
    send_fota_response "true" "Update applied successfully" "{\"version\": \"$latest_version\", \"backup\": \"$backup_file\"}"
}

# Execute main function
main
