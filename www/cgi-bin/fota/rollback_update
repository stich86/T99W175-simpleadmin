#!/bin/bash

# SimpleAdmin Update System - Rollback Update
# Restores the previous version using directory rename (instant rollback)
# Uses background worker pattern to survive webserver restart

SCRIPT_DIR="/WEBSERVER/www/cgi-bin"
STATE_DIR="/data/simpleadmin"
STATE_FILE="${STATE_DIR}/update-state.json"
ROLLBACK_LOG="/tmp/simpleadmin-rollback-worker.log"
ROLLBACK_LOCK="/tmp/simpleadmin-rollback-worker.lock"

# Configuration
WWW_DIR="/WEBSERVER/www"
CONFIG_BACKUP_DIR="${STATE_DIR}/config_backup"

PRESERVE_FILES=(
    "config/simpleadmin.conf"
    "cgi-bin/credentials.txt"
)

# Check if running as background worker
if [ "$1" = "--worker" ]; then
    # Worker mode - execute rollback in background
    BACKUP_PATH="$2"

    log_msg() {
        local msg="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
        echo "$msg" >> "$ROLLBACK_LOG" 2>/dev/null || echo "$msg" >&2
    }

    log_error() {
        log_msg "ERROR: $1"
    }

    log_info() {
        log_msg "INFO: $1"
    }

    # Update state to rolling back
    update_state() {
        local status=$1
        local error_msg=$2
        sed -i 's/"status": "[^"]*"/"status": "'"$status"'"/' "$STATE_FILE" 2>/dev/null
        if [ -n "$error_msg" ]; then
            sed -i 's/"error_message": "[^"]*"/"error_message": "'"$error_msg"'"/' "$STATE_FILE" 2>/dev/null
        fi
    }

    # Check lock
    if [ -f "$ROLLBACK_LOCK" ]; then
        log_error "Rollback already running (lock file exists)"
        update_state "error" "Another rollback is already in progress"
        exit 1
    fi

    # Create lock
    echo "$$" > "$ROLLBACK_LOCK"

    # Cleanup on exit
    cleanup() {
        rm -f "$ROLLBACK_LOCK"
        log_info "Worker finished"
    }
    trap cleanup EXIT

    log_info "=== Rollback Worker Started ==="
    log_info "Backup path: $BACKUP_PATH"

    # Wait a moment for HTTP response
    sleep 2

    # Find existing backup directory (there should be only one with our new strategy)
    # Don't rely on backup_path from JSON - it may be stale
    BACKUP_PATH=""
    for dir in "${WWW_DIR}-"*; do
        if [ -d "$dir" ]; then
            BACKUP_PATH="$dir"
            break
        fi
    done

    if [ -z "$BACKUP_PATH" ]; then
        log_error "No backup directory found (${WWW_DIR}-*)"
        update_state "error" "No backup directory found"
        exit 1
    fi

    log_info "Found backup: $BACKUP_PATH"
    log_info "Restore version: $RESTORE_VERSION"

    # Read current state
    state_data=$(cat "$STATE_FILE" 2>/dev/null)
    current_version=$(echo "$state_data" | grep '"current_version":' | sed 's/.*"current_version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')

    # Step 1: Move current www to failed
    log_info "Step 1: Moving current www to failed..."
    FAILED_DIR="${WWW_DIR}.failed-$(date +%Y%m%d_%H%M%S)"
    if ! mv "$WWW_DIR" "$FAILED_DIR" 2>&1; then
        log_error "Failed to move current www directory"
        update_state "error" "Failed to backup current www"
        exit 1
    fi
    log_info "  Current www moved to: $FAILED_DIR"

    # Step 2: Restore backup
    log_info "Step 2: Restoring backup www directory..."
    if ! mv "$BACKUP_PATH" "$WWW_DIR" 2>&1; then
        log_error "Failed to restore backup directory"
        log_error "CRITICAL: Attempting to restore failed directory..."
        if mv "$FAILED_DIR" "$WWW_DIR" 2>&1; then
            log_info "  Failed directory restored"
        else
            log_error "  CRITICAL: System may be in broken state!"
        fi
        systemctl restart qcmap_httpd 2>/dev/null
        update_state "error" "Failed to restore backup (rollback attempted)"
        exit 1
    fi
    log_info "  Backup restored successfully"

    # Step 3: Set permissions
    log_info "Step 3: Setting permissions..."
    chmod -R 755 "$WWW_DIR"
    chmod +x "$WWW_DIR"/cgi-bin/* 2>/dev/null
    log_info "  Permissions set"

    # Step 4: Restore config files
    log_info "Step 4: Restoring configuration files..."
    for file in "${PRESERVE_FILES[@]}"; do
        filepath="${WWW_DIR}/${file}"
        backuppath="${CONFIG_BACKUP_DIR}/$(basename $file)"

        if [ -f "$backuppath" ]; then
            log_info "  Restoring: $file"
            cp "$backuppath" "$filepath"
            if [ "$file" = "cgi-bin/credentials.txt" ]; then
                chmod 600 "$filepath"
            else
                chmod 644 "$filepath"
            fi
        fi
    done
    log_info "  Configuration restored"

    # Step 5: Update state
    log_info "Step 5: Updating state..."
    # Swap current_version and previous_version
    sed -i 's/"current_version": "[^"]*"/"current_version": "'"$RESTORE_VERSION"'"/' "$STATE_FILE" 2>/dev/null
    sed -i 's/"previous_version": "[^"]*"/"previous_version": "'"$current_version"'"/' "$STATE_FILE" 2>/dev/null
    # Clear backup info
    sed -i 's/"backup_created": [^,}]*/"backup_created": false/' "$STATE_FILE" 2>/dev/null
    sed -i 's|"backup_path": "[^"]*"|"backup_path": ""|' "$STATE_FILE" 2>/dev/null
    log_info "  State updated"

    # Step 6: Restart web server
    log_info "Step 6: Restarting web server..."
    if ! systemctl restart qcmap_httpd 2>&1; then
        log_error "Failed to restart web server"
        update_state "error" "Failed to restart web server"
        exit 1
    fi
    log_info "  Web server restarted"

    # Wait for server to start
    sleep 2

    # Cleanup failed directory and old backup
    log_info "Step 7: Cleanup..."
    rm -rf "$FAILED_DIR" 2>/dev/null &
    rm -rf "${WWW_DIR}-"* 2>/dev/null &
    log_info "  Cleanup scheduled"

    # Update state to success
    update_state "success" ""

    log_info "=== Rollback Complete ==="
    log_info "Restored to version: $RESTORE_VERSION"

    exit 0
fi

# ============================================================================
# CGI Mode - Launch worker and return immediately
# ============================================================================

# Source session utils
set +e +u
. "$SCRIPT_DIR/session_utils.sh" 2>/dev/null || true
set -e 2>/dev/null || true

# Validate session
session_load 2>/dev/null || { send_json_response 401 '{"ok": false, "message": "Invalid session"}'; exit 1; }
session_require_role "admin" 2>/dev/null || { send_json_response 403 '{"ok": false, "message": "Admin privileges required"}'; exit 1; }

# Response function
send_response() {
    local ok=$1
    local msg=$2
    local refresh=$3
    local ver=$4

    cat <<EOF
Status: 200 OK
Content-type: application/json
Cache-Control: no-store

{"ok": $ok, "message": "$msg", "refresh_after": $refresh, "data": {"version": "$ver"}}
EOF
}

# JSON helpers - use jq if available, fallback to grep/sed
extract_json_field() {
    local json=$1
    local field=$2

    if command -v jq >/dev/null 2>&1; then
        echo "$json" | jq -r '.'"$field"' // empty'
    else
        echo "$json" | grep "\"$field\":" | sed 's/.*"'$field'" *: *"\([^"]*\)".*/\1/' | head -n 1
    fi
}

# Read state to get current version info
[ -f "$STATE_FILE" ] || { send_response "false" "State file not found" "0" ""; exit 1; }
state_data=$(cat "$STATE_FILE" 2>/dev/null)

# Extract current_version for response message
if command -v jq >/dev/null 2>&1; then
    current_version=$(echo "$state_data" | jq -r '.current_version // empty')
else
    current_version=$(extract_json_field "$state_data" "current_version")
fi

# Check if backup directory exists by looking for www-* pattern
BACKUP_FOUND=""
for dir in "${WWW_DIR}-"*; do
    if [ -d "$dir" ]; then
        BACKUP_FOUND="$dir"
        break
    fi
done

if [ -z "$BACKUP_FOUND" ]; then
    send_response "false" "Backup not found" "0" ""
    exit 1
fi

# Extract version from backup directory name
RESTORE_VERSION=$(basename "$BACKUP_FOUND" | sed 's/^www-//')
[ -z "$RESTORE_VERSION" ] || [ "$RESTORE_VERSION" = "null" ] && RESTORE_VERSION="unknown"

# Copy this script to /tmp
WORKER_SOURCE="$0"
WORKER_TARGET="/tmp/rollback_worker_$$.sh"

cp "$WORKER_SOURCE" "$WORKER_TARGET" 2>/dev/null || { send_response "false" "Failed to copy worker" "0" ""; exit 1; }
chmod +x "$WORKER_TARGET" 2>/dev/null

# Check systemd-run
which systemd-run >/dev/null 2>&1 || { send_response "false" "systemd-run not available" "0" ""; exit 1; }

# Update state to 'updating'
sed -i 's/"status": "[^"]*"/"status": "updating"/' "$STATE_FILE" 2>/dev/null || true

# Launch worker in background (worker will find backup directory itself)
systemd-run --quiet --scope "$WORKER_TARGET" --worker >/dev/null 2>&1 &

# Send response immediately
send_response "true" "Rollback started in background. Page will refresh." "30" "$RESTORE_VERSION"

exit 0
