#!/bin/bash

# SimpleAdmin Update System - Rollback Update
# Restores the previous version using directory rename (instant rollback)

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source session utilities
if [ -f "$SCRIPT_DIR/../session_utils.sh" ]; then
    . "$SCRIPT_DIR/../session_utils.sh"
else
    send_json_response 500 '{"ok": false, "message": "session_utils.sh not found"}'
    exit 1
fi

# Validate session and require admin
if ! session_load; then
    send_json_response 401 '{"ok": false, "message": "Invalid or expired session"}'
    exit 1
fi

if ! session_require_role "admin"; then
    send_json_response 403 '{"ok": false, "message": "Admin privileges required"}'
    exit 1
fi

# Configuration
STATE_DIR="/data/simpleadmin"
STATE_FILE="${STATE_DIR}/update-state.json"
BACKUP_DIR="${STATE_DIR}/backups"
ROLLBACK_TMP_DIR="${STATE_DIR}/rollback_tmp"
CONFIG_BACKUP_DIR="${STATE_DIR}/config_backup"
WWW_DIR="/WEBSERVER/www"

PRESERVE_FILES=(
    "config/simpleadmin.conf"
    "cgi-bin/credentials.txt"
)

# Helper functions
send_fota_response() {
    local ok=$1
    local message=$2
    local data=$3

    local payload
    payload="{\"ok\": $ok, \"message\": \"$message\", \"data\": $data}"

    send_json_response 200 "$payload"
}

log_error() {
    local msg="[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1"
    echo "$msg" >&2
    echo "$msg" >> /tmp/simpleadmin-fota.log
}

log_info() {
    local msg="[$(date '+%Y-%m-%d %H:%M:%S')] INFO: $1"
    echo "$msg" >&2
    echo "$msg" >> /tmp/simpleadmin-fota.log
}

# Restore from backup using directory rename (instant!)
restore_backup() {
    local backup_path=$1

    log_info "Restoring from backup: $backup_path"

    # Verify backup directory exists
    if [ ! -d "$backup_path" ]; then
        log_error "Backup directory not found: $backup_path"
        return 1
    fi

    # Move current www to failed (atomic operation)
    log_info "Step 1: Moving current www to failed..."
    FAILED_DIR="${WWW_DIR}.failed-$(date +%Y%m%d_%H%M%S)"

    if ! mv "$WWW_DIR" "$FAILED_DIR" 2>&1; then
        log_error "Failed to move current www directory"
        return 1
    fi
    log_info "  Current www moved to: $FAILED_DIR"

    # Move backup into place (atomic operation)
    log_info "Step 2: Restoring backup www directory..."
    if ! mv "$backup_path" "$WWW_DIR" 2>&1; then
        log_error "Failed to restore backup directory"
        log_error "CRITICAL: Attempting to restore failed directory..."
        # Try to restore the failed directory
        if mv "$FAILED_DIR" "$WWW_DIR" 2>&1; then
            log_info "  Failed directory restored"
        else
            log_error "  CRITICAL: System may be in broken state!"
        fi
        systemctl restart qcmap_httpd 2>/dev/null
        return 1
    fi
    log_info "  Backup restored successfully"

    # Set permissions
    log_info "Step 3: Setting permissions..."
    chmod -R 755 "$WWW_DIR"
    chmod +x "$WWW_DIR"/cgi-bin/* 2>/dev/null
    log_info "  Permissions set"

    # Restore configuration files
    log_info "Step 4: Restoring configuration files..."
    for file in "${PRESERVE_FILES[@]}"; do
        local filepath="${WWW_DIR}/${file}"
        local backuppath="${CONFIG_BACKUP_DIR}/$(basename $file)"

        if [ -f "$backuppath" ]; then
            log_info "  Restoring: $file"
            cp "$backuppath" "$filepath"

            if [ "$file" = "cgi-bin/credentials.txt" ]; then
                chmod 600 "$filepath"
            else
                chmod 644 "$filepath"
            fi
        fi
    done
    log_info "  Configuration restored"

    # Restart web server
    log_info "Step 5: Restarting web server..."
    if ! systemctl restart qcmap_httpd 2>&1; then
        log_error "Failed to restart web server"
        return 1
    fi
    log_info "  Web server restarted"

    # Wait for server to start
    sleep 2

    # Cleanup failed directory in background
    log_info "Step 6: Cleanup..."
    rm -rf "$FAILED_DIR" 2>/dev/null &
    log_info "  Cleanup scheduled"

    log_info "Rollback completed successfully"
    return 0
}

# Main execution
main() {
    # Extract field from JSON
    extract_json_field() {
        local json=$1
        local field=$2
        echo "$json" | grep "\"$field\":" | sed 's/.*"'$field'" *: *"\([^"]*\)".*/\1/' | head -n 1
    }

    # Read state to get backup path
    if [ ! -f "$STATE_FILE" ]; then
        log_error "State file not found"
        send_fota_response "false" "State file missing" "{}"
        exit 1
    fi

    local state_data
    state_data=$(cat "$STATE_FILE" 2>/dev/null)

    # Extract backup path
    local backup_path
    backup_path=$(extract_json_field "$state_data" "backup_path")

    # Check if backup path exists
    if [ -z "$backup_path" ] || [ "$backup_path" = "null" ]; then
        log_error "No backup path found in state"
        send_fota_response "false" "No backup available" "{}"
        exit 1
    fi

    # Check if backup directory exists
    if [ ! -d "$backup_path" ]; then
        log_error "Backup directory not found: $backup_path"
        send_fota_response "false" "Backup directory missing" "{}"
        exit 1
    fi

    # Perform rollback
    if ! restore_backup "$backup_path"; then
        send_fota_response "false" "Failed to restore backup" "{}"
        exit 1
    fi

    log_info "Rollback successful"
    send_fota_response "true" "Rollback completed successfully" "{\"backup\": \"$backup_path\"}"
}

# Execute main function
main
