#!/bin/bash

# SimpleAdmin Update System - Check for Updates
# Checks GitHub Releases API for new versions

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
JQ_BIN="/usr/bin/jq"

# Source session utilities
if [ -f "$SCRIPT_DIR/../session_utils.sh" ]; then
    . "$SCRIPT_DIR/../session_utils.sh"
else
    send_json_response 500 '{"ok": false, "message": "session_utils.sh not found"}'
    exit 1
fi

# Configuration
GITHUB_REPO="stich86/T99W175-simpleadmin"
STATE_DIR="/data/simpleadmin"
STATE_FILE="${STATE_DIR}/update-state.json"
VERSION_FILE="/WEBSERVER/www/VERSION"

# Get channel from query string or state file
get_channel() {
    # Check QUERY_STRING for channel parameter
    if [[ "$QUERY_STRING" =~ channel=([^&]+) ]]; then
        local channel="${BASH_REMATCH[1]}"
        if [[ "$channel" == "stable" || "$channel" == "beta" ]]; then
            echo "$channel"
            return 0
        fi
    fi

    # Check state file for saved channel
    if [ -f "$STATE_FILE" ]; then
        local saved_channel
        saved_channel=$(grep -o '"channel"[[:space:]]*:[[:space:]]*"[^"]*"' "$STATE_FILE" | sed 's/.*"channel"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
        if [[ -n "$saved_channel" ]]; then
            echo "$saved_channel"
            return 0
        fi
    fi

    # Default to stable
    echo "stable"
    return 0
}

# Helper functions
send_fota_response() {
    local ok=$1
    local message=$2
    local data=$3

    local payload
    payload="{\"ok\": $ok, \"message\": \"$message\", \"data\": $data}"

    send_json_response 200 "$payload"
}

log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1" >&2
}

log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] INFO: $1" >&2
}

# Get current version
get_current_version() {
    if [ -f "$VERSION_FILE" ]; then
        cat "$VERSION_FILE" | tr -d '[:space:]'
    else
        echo "unknown"
    fi
}

# Compare versions (returns 0 if $1 = $2, 1 if $1 > $2, 2 if $1 < $2)
# BusyBox-compatible version comparison (no arrays)
compare_versions() {
    if [ "$1" = "$2" ]; then
        return 0
    fi

    # Compare each part using cut
    local i=1
    while true; do
        local p1=$(echo "$1" | cut -d. -f$i)
        local p2=$(echo "$2" | cut -d. -f$i)

        # If both parts are empty, versions are equal
        if [ -z "$p1" ] && [ -z "$p2" ]; then
            break
        fi

        # Default to 0 if empty
        [ -z "$p1" ] && p1=0
        [ -z "$p2" ] && p2=0

        # Remove non-numeric suffixes (like -beta1)
        p1=$(echo "$p1" | grep -o '^[0-9]*')
        p2=$(echo "$p2" | grep -o '^[0-9]*')

        [ -z "$p1" ] && p1=0
        [ -z "$p2" ] && p2=0

        if [ "$p1" -gt "$p2" ] 2>/dev/null; then
            return 1
        elif [ "$p1" -lt "$p2" ] 2>/dev/null; then
            return 2
        fi

        i=$((i + 1))
    done

    return 0
}

# Fetch latest release from GitHub
fetch_latest_release() {
    local channel="$1"  # stable or beta
    local api_url

    if [[ "$channel" == "beta" ]]; then
        api_url="https://api.github.com/repos/${GITHUB_REPO}/releases?per_page=5"
        log_info "Fetching beta releases from GitHub..."
    else
        # For stable, also fetch multiple to get history
        api_url="https://api.github.com/repos/${GITHUB_REPO}/releases?per_page=3"
        log_info "Fetching stable releases from GitHub..."
    fi

    local response
    response=$(curl -k -s "$api_url" 2>&1)

    if [ $? -ne 0 ]; then
        log_error "Failed to fetch from GitHub"
        return 1
    fi

    if [ ! -x "$JQ_BIN" ]; then
        log_error "jq not found at $JQ_BIN"
        return 2
    fi

    local releases_json
    local filter

    if [[ "$channel" == "beta" ]]; then
        # Filter for prerelease only, take first 3
        filter='[.[] | select(.prerelease == true)] | .[0:3]'
    else
        # Filter for non-prerelease only, take first 3
        filter='[.[] | select(.prerelease == false)] | .[0:3]'
    fi

    releases_json=$(echo "$response" | "$JQ_BIN" "$filter" 2>/dev/null)
    local jq_exit_code=$?

    if [ $jq_exit_code -ne 0 ]; then
        log_error "jq parsing failed"
        return 2
    fi

    # Check if empty
    local release_count
    release_count=$(echo "$releases_json" | "$JQ_BIN" 'length' 2>/dev/null)

    if [[ "$release_count" == "0" ]] || [[ "$release_count" == "null" ]]; then
        log_info "No releases found for channel: $channel"
        return 1
    fi

    # Output all releases as JSON array
    echo "$releases_json"
    return 0
}

# Update state file
update_state() {
    local current_version=$1
    local latest_version=$2
    local download_url=$3
    local changelog=$4
    local update_available=$5
    local channel=$6
    local available_releases=$7  # JSON array of available releases

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Escape changelog for JSON
    changelog=$(echo "$changelog" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')

    # Preserve existing backup info if state file exists
    local existing_backup_created="false"
    local backup_path_value=""
    local backup_path_empty=false

    if [ -f "$STATE_FILE" ]; then
        existing_backup_created=$(grep -o '"backup_created"[[:space:]]*:[[:space:]]*[a-z]*' "$STATE_FILE" 2>/dev/null | sed 's/.*"backup_created"[[:space:]]*:[[:space:]]*\([a-z]*\).*/\1/')
        local raw_path
        raw_path=$(grep -o '"backup_path"[[:space:]]*:[[:space:]]*"[^"]*"' "$STATE_FILE" 2>/dev/null | sed 's/.*"backup_path"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')

        [ -z "$existing_backup_created" ] && existing_backup_created="false"

        # Check if path is empty
        if [ -z "$raw_path" ]; then
            backup_path_empty=true
        else
            backup_path_value="$raw_path"
        fi
    fi

    # Build backup_path JSON value
    local backup_path_json
    if [ "$backup_path_empty" = "true" ]; then
        backup_path_json='""'
    else
        # Escape quotes in path
        backup_path_json="\"$(echo "$backup_path_value" | sed 's/"/\\"/g')\""
    fi

    # Create state file manually, preserving backup info
    cat > "$STATE_FILE" <<EOF
{
  "channel": "$channel",
  "current_version": "$current_version",
  "latest_version": "$latest_version",
  "update_available": $update_available,
  "update_downloaded": false,
  "backup_created": $existing_backup_created,
  "backup_path": $backup_path_json,
  "download_path": "",
  "status": "idle",
  "last_check": "$timestamp",
  "download_url": "$download_url",
  "changelog": "$changelog",
  "available_releases": $available_releases,
  "error_message": ""
}
EOF
}

# Main execution
main() {
    # CRITICAL: Check if running as CGI
    if [ -z "${REQUEST_METHOD:-}" ] && [ -z "${GATEWAY_INTERFACE:-}" ]; then
        send_json_response 400 '{"ok": false, "message": "This script must be run as CGI"}'
        exit 1
    fi

    # Validate session and require admin FIRST
    if ! session_load; then
        send_json_response 401 '{"ok": false, "message": "Invalid or expired session"}'
        exit 1
    fi

    if ! session_require_role "admin"; then
        send_json_response 403 '{"ok": false, "message": "Admin privileges required"}'
        exit 1
    fi

    # Create state directory
    mkdir -p "$STATE_DIR"

    # Get channel
    local channel
    channel=$(get_channel)
    log_info "Update channel: $channel"

    # Get current version
    local current_version
    current_version=$(get_current_version)

    log_info "Current version: $current_version"

    # Fetch releases for channel (returns JSON array)
    local releases_json
    releases_json=$(fetch_latest_release "$channel")
    local fetch_result=$?

    # Handle different fetch results
    if [ $fetch_result -eq 2 ]; then
        # Actual error (jq failed, timeout, etc.)
        send_fota_response "false" "Failed to check for updates" "{}"
        exit 1
    elif [ $fetch_result -eq 1 ]; then
        # No releases available
        if [[ "$channel" == "beta" ]]; then
            log_info "No beta releases available - creating empty state"

            # Create empty state for beta
            latest_version="$current_version"
            download_url=""
            changelog="No beta releases available at this time."
            releases_json="[]"
            update_available="false"

            # Update state with empty releases
            update_state "$current_version" "$latest_version" "$download_url" "$changelog" "$update_available" "$channel" "$releases_json"

            # Send response
            send_fota_response "true" "Already up to date" "$(cat "$STATE_FILE")"
            exit 0
        else
            log_error "No stable releases found - this should not happen"
            send_fota_response "false" "Failed to fetch release info" "{}"
            exit 1
        fi
    else
        # Success - extract first release as "latest"
        latest_version=$(echo "$releases_json" | "$JQ_BIN" -r '.[0].tag_name // empty' 2>/dev/null | sed 's/^v//')

        if [ -z "$latest_version" ] || [ "$latest_version" = "null" ]; then
            log_error "Failed to extract version from releases"
            send_fota_response "false" "Failed to parse release data" "{}"
            exit 1
        fi

        download_url=$(echo "$releases_json" | "$JQ_BIN" -r '.[0].assets[] | select(.name | endswith(".tar.gz")) | .browser_download_url // empty' 2>/dev/null | head -n 1)
        changelog=$(echo "$releases_json" | "$JQ_BIN" -r '.[0].body // ""' 2>/dev/null | head -c 500)

        log_info "Latest $channel version: $latest_version"
        log_info "Available releases: $(echo "$releases_json" | "$JQ_BIN" 'length')"

        # Compare versions
        local update_available="false"
        local comparison
        # Temporarily disable set -e to allow non-zero return
        set +e
        compare_versions "$current_version" "$latest_version"
        comparison=$?
        set -e

        if [ $comparison -eq 2 ]; then
            update_available="true"
            log_info "Update available!"
        else
            update_available="false"
            log_info "Already up to date"
        fi
    fi

    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Update state with all available releases (even if empty for beta)
    update_state "$current_version" "$latest_version" "$download_url" "$changelog" "$update_available" "$channel" "$releases_json"

    # Send response - read from state file
    local message
    if [ "$update_available" = "true" ]; then
        message="New version available: $latest_version"
    else
        message="Already up to date"
    fi

    send_fota_response "true" "$message" "$(cat "$STATE_FILE")"
}

# Execute main function
main
