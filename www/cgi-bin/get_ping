#!/bin/bash
set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=/dev/null
. "$SCRIPT_DIR/session_utils.sh"

# Function to send error response and exit
send_error_response() {
    local message="$1"
    send_json_response 200 "{\"status\":\"error\",\"message\":\"$message\"}"
    exit 0
}

# Trap errors and ensure we always send a response
trap 'send_error_response "Unexpected error during connectivity test"' ERR

if ! session_load; then
    send_json_response 401 '{"status":"error","message":"Authentication required"}'
    exit 0
fi

# Load configuration from simpleadmin.conf
CONFIG_FILE="$SCRIPT_DIR/../config/simpleadmin.conf"
if [ -f "$CONFIG_FILE" ]; then
    . "$CONFIG_FILE"
fi

# Use configured values or defaults
PING_TARGETS="${SIMPLEADMIN_PING_TARGETS:-8.8.8.8,1.1.1.1}"
DNS_TESTS="${SIMPLEADMIN_DNS_TESTS:-8.8.8.8:www.google.com,1.1.1.1:www.google.com}"

# Test ping connectivity
ping_results=()
ping_count=0
ping_times=()

IFS=',' read -ra TARGETS <<< "$PING_TARGETS"
for target in "${TARGETS[@]}"; do
    target=$(echo "$target" | xargs) # trim whitespace
    # Capture ping output to extract time
    ping_output=$(ping -c 1 -W 1 "$target" 2>&1) || ping_output=""
    ping_exit=$?

    # Check if ping actually succeeded (not just completed)
    # A successful ping should have "0% packet loss" or include "time=" with a value
    ping_success=false
    if [ $ping_exit -eq 0 ]; then
        # Check for 100% packet loss (ping completed but no response)
        if echo "$ping_output" | grep -q "100% packet loss"; then
            ping_success=false
        # Check if we got a time value (actual response)
        elif echo "$ping_output" | grep -q "time="; then
            ping_success=true
        else
            ping_success=false
        fi
    fi

    if [ "$ping_success" = true ]; then
        # Extract time from ping output (format: time=12.345 ms)
        # Use sed to extract the time value (more portable than grep -P)
        ping_time=$(echo "$ping_output" | sed -n 's/.*time=\([0-9.]*\).*/\1/p' | head -n1)
        
        if [ -n "$ping_time" ] && [ "$ping_time" != "0" ]; then
            ping_results+=("{\"host\":\"$target\",\"status\":\"ok\",\"time\":$ping_time}")
            ping_times+=("$ping_time")
            ping_count=$((ping_count + 1))
        else
            # Fallback: try awk method
            ping_time=$(echo "$ping_output" | awk -F'time=' '/time=/ {print $2}' | awk '{print $1}' | head -n1)
            if [ -n "$ping_time" ] && [ "$ping_time" != "0" ]; then
                ping_results+=("{\"host\":\"$target\",\"status\":\"ok\",\"time\":$ping_time}")
                ping_times+=("$ping_time")
                ping_count=$((ping_count + 1))
            else
                ping_results+=("{\"host\":\"$target\",\"status\":\"ok\"}")
                ping_count=$((ping_count + 1))
            fi
        fi
    else
        ping_results+=("{\"host\":\"$target\",\"status\":\"failed\"}")
    fi
done

# Calculate average ping time (or use last one if only one ping)
ping_avg_time="null"
if [ ${#ping_times[@]} -gt 0 ]; then
    if [ ${#ping_times[@]} -eq 1 ]; then
        # If only one ping, use that time
        ping_avg_time="${ping_times[0]}"
    else
        # Calculate average using awk (since bc is not available)
        ping_avg_time=$(printf '%s\n' "${ping_times[@]}" | awk '{sum+=$1; count++} END {if(count>0) printf "%.3f", sum/count; else print "0"}')
    fi
fi

# Test DNS resolution
dns_results=()
dns_count=0

IFS=',' read -ra DNS_ARRAY <<< "$DNS_TESTS"
for dns_test in "${DNS_ARRAY[@]}"; do
    dns_test=$(echo "$dns_test" | xargs) # trim whitespace
    server="${dns_test%%:*}"
    domain="${dns_test#*:}"

    # Test with 2 second timeout using dig's built-in timeout parameter
    dig_output=$(dig @"$server" +timeout=2 +short "$domain" 2>&1)
    dig_exit=$?

    # Check if dig actually returned results (not just completed)
    dig_success=false
    if [ $dig_exit -eq 0 ]; then
        # Check if output is not empty and has actual DNS records
        if [ -n "$dig_output" ]; then
            # Filter out empty lines and comments
            result_count=$(echo "$dig_output" | grep -v '^;' | grep -v '^$' | wc -l)
            if [ "$result_count" -gt 0 ]; then
                dig_success=true
            fi
        fi
    fi

    if [ "$dig_success" = true ]; then
        dns_results+=("{\"server\":\"$server\",\"domain\":\"$domain\",\"status\":\"ok\"}")
        dns_count=$((dns_count + 1))
    else
        dns_results+=("{\"server\":\"$server\",\"domain\":\"$domain\",\"status\":\"failed\"}")
    fi
done || true

# Build JSON arrays
ping_json=$(IFS=,; echo "${ping_results[*]}")
dns_json=$(IFS=,; echo "${dns_results[*]}")

# Calculate totals
total_targets=${#TARGETS[@]}
total_dns=${#DNS_ARRAY[@]}
total_tests=$((ping_count + dns_count))
max_tests=$((total_targets + total_dns))

# Determine connectivity status
if [ "$total_tests" -eq "$max_tests" ]; then
    # All connectivity checks passed
    status="ok"
elif [ "$total_tests" -gt 0 ]; then
    # Partial connectivity - some tests passed
    status="warning"
else
    # No connectivity at all
    status="error"
fi

# Build response JSON
response="{
  \"status\": \"$status\",
  \"connected\": $([ "$status" != "error" ] && echo "true" || echo "false"),
  \"ping\": {
    \"total\": $total_targets,
    \"passed\": $ping_count,
    \"avgTime\": $ping_avg_time,
    \"results\": [$ping_json]
  },
  \"dns\": {
    \"total\": $total_dns,
    \"passed\": $dns_count,
    \"results\": [$dns_json]
  }
}"

send_json_response 200 "$response"